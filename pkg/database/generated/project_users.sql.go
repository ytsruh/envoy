// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: project_users.sql

package database

import (
	"context"
	"database/sql"
)

const addUserToProject = `-- name: AddUserToProject :one
INSERT INTO project_users (project_id, user_id, role, created_at, updated_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, project_id, user_id, role, created_at, updated_at
`

type AddUserToProjectParams struct {
	ProjectID int64
	UserID    string
	Role      string
	CreatedAt sql.NullTime
	UpdatedAt interface{}
}

func (q *Queries) AddUserToProject(ctx context.Context, arg AddUserToProjectParams) (ProjectUser, error) {
	row := q.db.QueryRowContext(ctx, addUserToProject,
		arg.ProjectID,
		arg.UserID,
		arg.Role,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ProjectUser
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const canUserModifyProject = `-- name: CanUserModifyProject :one
SELECT COUNT(*) as count
FROM projects p
LEFT JOIN project_users pu ON p.id = pu.project_id
WHERE p.id = ? AND p.deleted_at IS NULL
AND (
    p.owner_id = ? OR 
    (pu.user_id = ? AND pu.role = 'editor')
)
`

type CanUserModifyProjectParams struct {
	ID      int64
	OwnerID string
	UserID  string
}

func (q *Queries) CanUserModifyProject(ctx context.Context, arg CanUserModifyProjectParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, canUserModifyProject, arg.ID, arg.OwnerID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAccessibleProject = `-- name: GetAccessibleProject :one
SELECT p.id, p.name, p.description, p.git_repo, p.owner_id, p.created_at, p.updated_at, p.deleted_at
FROM projects p
WHERE p.id = ? AND p.deleted_at IS NULL
AND (p.owner_id = ? OR EXISTS (
    SELECT 1 FROM project_users pu 
    WHERE pu.project_id = p.id AND pu.user_id = ?
))
`

type GetAccessibleProjectParams struct {
	ID      int64
	OwnerID string
	UserID  string
}

func (q *Queries) GetAccessibleProject(ctx context.Context, arg GetAccessibleProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, getAccessibleProject, arg.ID, arg.OwnerID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.GitRepo,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProjectMemberRole = `-- name: GetProjectMemberRole :one
SELECT pu.role
FROM project_users pu
WHERE pu.project_id = ? AND pu.user_id = ?
`

type GetProjectMemberRoleParams struct {
	ProjectID int64
	UserID    string
}

func (q *Queries) GetProjectMemberRole(ctx context.Context, arg GetProjectMemberRoleParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getProjectMemberRole, arg.ProjectID, arg.UserID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getProjectMembership = `-- name: GetProjectMembership :one
SELECT pu.id, pu.project_id, pu.user_id, pu.role, pu.created_at, pu.updated_at
FROM project_users pu
WHERE pu.project_id = ? AND pu.user_id = ?
`

type GetProjectMembershipParams struct {
	ProjectID int64
	UserID    string
}

func (q *Queries) GetProjectMembership(ctx context.Context, arg GetProjectMembershipParams) (ProjectUser, error) {
	row := q.db.QueryRowContext(ctx, getProjectMembership, arg.ProjectID, arg.UserID)
	var i ProjectUser
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectUsers = `-- name: GetProjectUsers :many
SELECT pu.id, pu.project_id, pu.user_id, pu.role, pu.created_at, pu.updated_at
FROM project_users pu
INNER JOIN users u ON pu.user_id = u.id
WHERE pu.project_id = ?
ORDER BY pu.created_at ASC
`

func (q *Queries) GetProjectUsers(ctx context.Context, projectID int64) ([]ProjectUser, error) {
	rows, err := q.db.QueryContext(ctx, getProjectUsers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectUser
	for rows.Next() {
		var i ProjectUser
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProjects = `-- name: GetUserProjects :many
SELECT DISTINCT p.id, p.name, p.description, p.git_repo, p.owner_id, p.created_at, p.updated_at, p.deleted_at
FROM projects p
LEFT JOIN project_users pu ON p.id = pu.project_id
WHERE (p.owner_id = ? OR pu.user_id = ?) AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
`

type GetUserProjectsParams struct {
	OwnerID string
	UserID  string
}

func (q *Queries) GetUserProjects(ctx context.Context, arg GetUserProjectsParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getUserProjects, arg.OwnerID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.GitRepo,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isProjectOwner = `-- name: IsProjectOwner :one
SELECT COUNT(*) as count
FROM projects
WHERE id = ? AND owner_id = ? AND deleted_at IS NULL
`

type IsProjectOwnerParams struct {
	ID      int64
	OwnerID string
}

func (q *Queries) IsProjectOwner(ctx context.Context, arg IsProjectOwnerParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isProjectOwner, arg.ID, arg.OwnerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeUserFromProject = `-- name: RemoveUserFromProject :exec
DELETE FROM project_users
WHERE project_id = ? AND user_id = ?
`

type RemoveUserFromProjectParams struct {
	ProjectID int64
	UserID    string
}

func (q *Queries) RemoveUserFromProject(ctx context.Context, arg RemoveUserFromProjectParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromProject, arg.ProjectID, arg.UserID)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE project_users
SET role = ?, updated_at = ?
WHERE project_id = ? AND user_id = ?
`

type UpdateUserRoleParams struct {
	Role      string
	UpdatedAt interface{}
	ProjectID int64
	UserID    string
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole,
		arg.Role,
		arg.UpdatedAt,
		arg.ProjectID,
		arg.UserID,
	)
	return err
}
